\documentclass{article}
\input{header}

% https://ctan.org/pkg/syntax-mdw
% provides grammar environment for CFG typesetting
\usepackage{syntax}
\setlength{\grammarparsep}{2pt}
\def\lrep{\synshortsoff\texttt{\{}\synshorts~}
\def\rrep{\synshortsoff\texttt{\}}\synshorts~}
\def\lopt{\synshortsoff\texttt{[}\synshorts~}
\def\ropt{\synshortsoff\texttt{]}\synshorts~}
\def\lgrp{\synshortsoff\texttt{(}\synshorts~}
\def\rgrp{\synshortsoff\texttt{)}\synshorts~}
\usepackage{hyperref}

\title{The C Programming Language Specification}

\begin{document}
\maketitle

\section*{Notation}
The syntax is specified using a variant of Extended Backus-Naur Form (EBNF) defined in the \href{https://go.dev/ref/spec#Notation}{Go Programming Language Specification}:
\begin{grammar}
  <Syntax> ::= \lrep <Production> \rrep .
  
  <Production> ::= `<' "production_name" `>' `::=' \lopt <Expression> \ropt `.' .
  
  <Expression> ::= <Term> \lrep `|' <Term> \rrep .
  
  <Term> ::= <Factor> \lrep <Factor> \rrep .
  
  <Factor> ::= "production_name" | "token" \lopt `\ldots' "token" \ropt | <Group> | <Option> | <Repetition> .
  
  <Group> ::= `(' <Expression> `)' .
  
  <Option> ::= `[' <Expression> `]' .
  
  <Repetition> ::= `{' <Expression> `}' .

  <Test> ::= \lgrp <Expression> \rgrp .
  
\end{grammar}
% TODO: explain
\section*{Source code representation}
Source code must be plain ASCII text. Additionally, of the ASCII
characters, only the following belonging to these categories may
appear in the source text:
\begin{grammar}
  <newline> ::= "the ASCII code 10 (0x0a)" .

  <white_space> ::= \lgrp <new_line> | "the ASCII code 32 (0x20)" | "the ASCII code 13 (0x0d)" \rgrp \lrep <new_line> | "the ASCII code 32 (0x20)" | "the ASCII code 13 (0x0d)" \rrep .

  <letter> ::= 'A' \ldots 'Z' | 'a' \ldots 'z' | '_' .

  <decimal_digit> ::= '0' \ldots '9' .

  <binary_digit> ::= '0' | '1' .

  <octal_digit> ::= '0' \ldots '7' .

  <hex_digit> ::= '0' \ldots '9' | 'A' \ldots 'F' | 'a' \ldots 'f' .

  <printable_ascii> ::= "the ASCII code 32 (0x20)" \ldots "the ASCII code 126 (0x7e)" .
  
\end{grammar}
Note that this disallows most control characters, the NUL character,
and any extended ASCII characters (above 127). Arbitrary bytes may be
represented in strings using various escape sequences. %TODO: described later
\section*{Lexical elements}
\subsection*{Comments}
Comments are ignored by the compiler and may come in two forms: (1)
single-line comments beginning with
\texttt{\textbackslash\textbackslash} and (2) multi-line comments
beginning with \texttt{\textbackslash*} and terminated with
\texttt{*\textbackslash}.

Note that the compiler identifies and treats these separately from
tokens (i.e. they are ignored rather than tokenized), since they don't
have impact on program meaning/form.

\subsection*{Tokens}
There are four classes of tokens recognized by the compiler:
\emph{identifiers}, \emph{keywords}, \emph{operators \& punctuation},
and \emph{literals}. \emph{white\_space} is ignored except as it
separates tokens, in which case one or more ``white space'' characters
are essentially compressed into one white space rule noted in the
character categories above. A token in the source code consists of the
longest sequence of characters which match its definition (i.e. the
lexer is greedy).

\subsection*{Identifiers}
\begin{grammar}
  <identifier> ::= <letter> \lrep <letter> | <digit> \rrep
\end{grammar}

\subsection*{Keywords}
Keywords are any of the following (case-insensitive):
\begin{verbatim}
if, else, return, switch, case, while, break, continue
\end{verbatim}

\subsection*{Operators \& Punctuation}
The following are recognized as either operators or punctuation:
% TODO: is '?' a valid operator in C?
% TODO: and '\', is that for line-breaks?
\begin{verbatim}
;, :, ?, +, -, /, *, <, >, =, !, &, |, [, ], ^, (, ), ,, {, }, \, !=, ==, <=, &&, ||, ++, --
\end{verbatim}

\subsection*{Literals}
\subsubsection*{Integer literals}
\begin{grammar}
  <integer_lit> ::= <decimal_lit> | <hex_lit> | <binary_lit> | <octal_lit> .

  <decimal_lit> ::= \lgrp `0' \ldots `9' \rgrp \lopt \lopt `\'' \ropt <decimal_digits> \ropt .

  <hex_lit> ::= `0' \lgrp `x' | `X' \rgrp \lopt `\'' \ropt <hex_digits> .

  <binary_lit> ::= `0' \lgrp `b' | `B' \rgrp \lopt `\'' \ropt <binary_digits> .

  <octal_lit> ::= `0' \lgrp `o' | `O' \rgrp \lopt `\'' \ropt <octal_digits> .

  <decimal_digits> ::= <decimal_digit> \lrep \lopt `\'' \ropt <decimal_digit> \rrep .

  <hex_digits> ::= <hex_digit> \lrep \lopt `\'' \ropt <hex_digit> \rrep .

  <binary_digits> ::= <binary_digit> \lrep \lopt `\'' \ropt <binary_digit> \rrep .

  <octal_digits> ::= <octal_digit> \lrep \lopt `\'' \ropt <octal_digit> \rrep .
\end{grammar}

For readability, a single \texttt{\'} character may appear after a base prefix or between successive digits.

\subsubsection*{Floating-point literals}
\begin{grammar}
  <float_lit> ::= <decimal_float_lit> . %TODO: add hex float literals

  <decimal_float_lit> ::= <decimal_digits> `.' \lopt <decimal_digits> \ropt
  \alt \lopt <decimal_digits> \ropt `.' <decimal_digits> .

  %TODO: add exponentials
\end{grammar}

\subsubsection*{Character literals}
\begin{grammar}
  <char_lit> ::= `\'' \lgrp <char_ascii_value> | <byte_value> \rgrp `\'' .

  <char_ascii_value> ::= <char_ascii> | <escaped_char> .

  % TODO: define an exception syntax in notation
  <char_ascii> ::= <printable_ascii> "\textbf{except}" \lgrp `\textbackslash' | `\'' \rgrp .

  <byte_value> ::= <octal_byte_value> | <hex_byte_value> .

  <octal_byte_value> ::= `\textbackslash' <octal_digit> <octal_digit> <octal_digit> .

  <hex_byte_value> ::= `\textbackslash x' <hex_digit> <hex_digit> .

  % https://en.wikipedia.org/wiki/Escape_sequences_in_C
  % except '?' because I don't know what trigraphs are
  <escaped_char> ::= `\textbackslash' \lgrp `a' | `b' | `e' | `f' | `n' | `r' | `t' | `v' | `\textbackslash' | `\'' | `\"' \rgrp .
\end{grammar}

\subsubsection*{String literals}
\begin{grammar}
  <string_lit> ::= `\"' \lrep <string_ascii_value> | <byte_value> \rrep `\"' .

  <string_ascii_value> ::= <string_ascii> | <escaped_char> .

  <string_ascii> ::= <printable_ascii> "\textbf{except}" \lgrp `\textbackslash' | `\"' \rgrp .
\end{grammar}

\end{document}
